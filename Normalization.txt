KEYS:-

| **Concept**       | **Meaning**                                               | **Example**                   |
| :---------------- | :-------------------------------------------------------- | :---------------------------- |
| **Super Key**     | Any attribute(s) that can uniquely identify a record      | RollNo, Email, (RollNo, Name) |
| **Candidate Key** | Minimal Super Key (no extra attribute)                    | RollNo, Email                 |
| **Primary Key**   | One Candidate Key chosen officially                       | RollNo                        |
| **Composite Key** | Multi-column Candidate Key (made of 2 or more attributes) | (StudentID, Subject)          |
| **Alternate Key** | Remaining Candidate Keys after choosing Primary Key       | Email                         |

Normalisation:-
Normalisation is a process by which we can decompose or divide any relation into more 
than one relation to remove anomalies in relational database.
It is a step by step process and each step is known as Normal Form.
Normalisation is a reversible process.

Various Normal Forms:-

An SQL table can be created without being in 1NF,
but the 1NF concept is meant for database design, not for execution.

*SQL only creates tables â€” it does not check logical rules.At the MySQL or SQL syntax level, it only checks for things like:

Column name, Data type, Primary key constraint. Thatâ€™s it.

It doesnâ€™t check whether:

A column contains multiple values, or

There are repeated or multi-valued fields.

Thatâ€™s why SQL accepts data like "Maths, Science" as a single string and inserts it without any error.

* But Normalization is a design concept

Normalization (1NF, 2NF, 3NF, BCNF) is not applied inside SQL â€”
it is applied during the database design stage.

Its purpose is:
â€œTo design data in such a way that redundancy and anomalies are avoided.â€

1). First Normal Form (1NF):-
If all the attribute values in a relation (table) are atomic (single-valued), then the table is said to be in First Normal Form (1NF).
This means that each column must contain only one value, not repeated or composite values.

Example 1). (Employee Table):

EID	Name	Salary	Dept.No	Dept.Name
1	Shivi Goyal	10,000	2	Accounts
2	Amit Chopra	9,000	1	Sales

Problem:
Here, the Name column is not atomic, because it contains both First Name and Last Name combined.

 Solution (After applying 1NF):

EID	FirstName	LastName	Salary	Dept.No	Dept.Name
1	Shivi	Goyal	10,000	2	Accounts
2	Amit	Chopra	9,000	1	Sales

eg 2). Unnormalized Table (Not in 1NF)
RollNo	Name	Subjects
1	Riya Sharma	Maths, Science
2	Deepak Gupta	English, Science
Problem:
The Subjects column has multiple values (Maths, Science, etc.) in a single cell â€” this violates 1NF rule.
Now all attributes are atomic, so the table is in 1NF.
After 1NF (First Normal Form)
RollNo	Name	Subject
1	Riya Sharma	Maths
1	Riya Sharma	Science
2	Deepak Gupta	English

Explanation:

Each cell now contains only one value.

There are no repeating groups or arrays.

Anomalies still present in 1NF:

Repetition Problem:
Dept.Name is repeated for every employee in the same department.

Update Problem:
If the name of the â€œAccountsâ€ department changes, you must update it in every related record.

Insertion Problem:
You cannot add a new department if it has no employees yet, because employee data is required to insert a record.

Deletion Problem:
If the last employee of a department is deleted, the department information will also be lost.

2).  Second Normal Form (2NF):-
A relation (table) is in Second Normal Form (2NF) when:

It is already in First Normal Form (1NF), and

All nonâ€“primary key attributes are fully dependent on the entire primary key, not just a part of it.

In other words,
If the primary key is composite (made up of two or more columns),
then no column should depend on only a part of that key.

Example: Student Table

RollNo	Game		Name		Fee		Grade
1	Cricket		Amit		200		A
2	Badminton	Dheeraj		150		B
3	Cricket		Lalit		200		A
4	Badminton	Parul		150		C
5	Hockey		Jack		100		A
6	Cricket		John		200		C

Primary Key: (RollNo, Game)
Because a student (RollNo) can participate in multiple games.

Problems (Anomalies) in 1NF Table

1. Deletion Anomaly:
If â€œJackâ€ (who plays Hockey) is deleted,
then the information about the game â€œHockeyâ€ will also be lost.

2. Insertion Anomaly:
If we want to add a new game â€œBasketballâ€ with no players yet,
we cannot insert it because there is no RollNo.

3. Update Anomaly:
If the fee for â€œCricketâ€ changes,
we have to update every row where â€œCricketâ€ appears.
If one row is missed, the data becomes inconsistent.

Reason (Dependency Problem)

Dependency	Meaning
RollNo â†’ Name	Student name depends only on RollNo
Game â†’ Fee	Game fee depends only on Game
(RollNo, Game) â†’ Grade	Grade depends on both RollNo and Game

This means some columns are partially dependent on only one part of the composite key.
Thatâ€™s why the table is not in 2NF.

Solution (Convert to 2NF)

We split the table into three smaller tables:

1. Student Table

RollNo	Name
1	Amit
2	Dheeraj
3	Lalit
4	Parul
5	Jack
6	John

Dependency: RollNo â†’ Name

2. Games Table

Game		Fee
Cricket		200
Badminton	150
Hockey		100

Dependency: Game â†’ Fee

3. Performance Table

RollNo	Game		Grade
1	Cricket		A
2	Badminton	B
3	Cricket		A
4	Badminton	C
5	Hockey		A
6	Cricket		C

Dependency: (RollNo, Game) â†’ Grade

Now the tables are in 2NF!

All non-key attributes fully depend on their primary keys.
Partial dependency is removed.
There are no more Deletion, Insertion, or Update anomalies.
SQL:-
mysql> SHOW DATABASES;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| newbie             |
| performance_schema |
| school             |
| shop               |
| sys                |
+--------------------+
7 rows in set (0.01 sec)

mysql> USE student_db;
ERROR 1049 (42000): Unknown database 'student_db'
mysql> USE sys;
Database changed
mysql> CREATE TABLE Student (
    ->   RollNo INT PRIMARY KEY,
    ->   Name VARCHAR(50)
    -> );
Query OK, 0 rows affected (0.05 sec)

mysql>
mysql> INSERT INTO Student (RollNo, Name) VALUES
    -> (1, 'Amit'),
    -> (2, 'Dheeraj'),
    -> (3, 'Lalit'),
    -> (4, 'Parul'),
    -> (5, 'Jack'),
    -> (6, 'John');
Query OK, 6 rows affected (0.01 sec)
Records: 6  Duplicates: 0  Warnings: 0

mysql> select * from Student;
+--------+---------+
| RollNo | Name    |
+--------+---------+
|      1 | Amit    |
|      2 | Dheeraj |
|      3 | Lalit   |
|      4 | Parul   |
|      5 | Jack    |
|      6 | John    |
+--------+---------+
6 rows in set (0.00 sec)

mysql> CREATE TABLE Games (
    ->   Game VARCHAR(50) PRIMARY KEY,
    ->   Fee INT
    -> );
Query OK, 0 rows affected (0.05 sec)

mysql>
mysql> INSERT INTO Games (Game, Fee) VALUES
    -> ('Cricket', 200),
    -> ('Badminton', 150),
    -> ('Hockey', 100);
Query OK, 3 rows affected (0.01 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql> select * from Games;
+-----------+------+
| Game      | Fee  |
+-----------+------+
| Badminton |  150 |
| Cricket   |  200 |
| Hockey    |  100 |
+-----------+------+
3 rows in set (0.00 sec)

mysql> CREATE TABLE Performance (
    RollNo INT,
    Game VARCHAR(50),
    Grade CHAR(1),
    PRIMARY KEY (RollNo, Game),
    FOREIGN KEY (RollNo) REFERENCES Student(RollNo),
    FOREIGN KEY (Game) REFERENCES Games(Game)
    );
Query OK, 0 rows affected (0.07 sec)

mysql>
mysql> INSERT INTO Performance (RollNo, Game, Grade) VALUES
    (1, 'Cricket', 'A'),
    (2, 'Badminton', 'B'),
    (3, 'Cricket', 'A'),
    (4, 'Badminton', 'C'),
    (5, 'Hockey', 'A'),
    (6, 'Cricket', 'C');
Query OK, 6 rows affected (0.00 sec)
Records: 6  Duplicates: 0  Warnings: 0

mysql> SELECT * FROM Performance;
+--------+-----------+-------+
| RollNo | Game      | Grade |
+--------+-----------+-------+
|      1 | Cricket   | A     |
|      2 | Badminton | B     |
|      3 | Cricket   | A     |
|      4 | Badminton | C     |
|      5 | Hockey    | A     |
|      6 | Cricket   | C     |
+--------+-----------+-------+
6 rows in set (0.00 sec)
mysql> DELETE FROM Student WHERE RollNo = 5;
ERROR 1451 (23000): Cannot delete or update a parent row: a foreign key constraint fails (`sys`.`performance`, CONSTRAINT `performance_ibfk_1` FOREIGN KEY (`RollNo`) REFERENCES `student` (`RollNo`))
mysql> DELETE FROM Performance WHERE RollNo = 5;
Query OK, 1 row affected (0.01 sec)

mysql> DELETE FROM Student WHERE RollNo = 5;
Query OK, 1 row affected (0.01 sec)

mysql> SELECT * FROM Student;
+--------+---------+
| RollNo | Name    |
+--------+---------+
|      1 | Amit    |
|      2 | Dheeraj |
|      3 | Lalit   |
|      4 | Parul   |
|      6 | John    |
+--------+---------+
5 rows in set (0.00 sec)

mysql> INSERT INTO Games (Game, Fee) VALUES ('Basketball', 120);
 SELECT * FROM Games;
+------------+------+
| Game       | Fee  |
+------------+------+
| Badminton  |  150 |
| Basketball |  120 |
| Cricket    |  200 |
| Hockey     |  100 |
+------------+------+

join using INNER JOIN:-
eg:
mysql> CREATE TABLE Student (
    ->   RollNo INT PRIMARY KEY,
    ->   Name VARCHAR(50)
    -> );
Query OK, 0 rows affected (0.03 sec)

mysql> CREATE TABLE Subject (
    ->   SubjectID INT PRIMARY KEY,
    ->   SubjectName VARCHAR(50)
    -> );
Query OK, 0 rows affected (0.02 sec)

mysql> CREATE TABLE Student_Subject (
    ->   RollNo INT,
    ->   SubjectID INT,
    ->   FOREIGN KEY (RollNo) REFERENCES Student(RollNo),
    ->   FOREIGN KEY (SubjectID) REFERENCES Subject(SubjectID)
    -> );
Query OK, 0 rows affected (0.06 sec)

mysql> INSERT INTO Student (RollNo, Name) VALUES
    -> (1, 'Riya Sharma'),
    -> (2, 'Aman Verma'),
    -> (3, 'Sanya Kapoor');
Query OK, 3 rows affected (0.01 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql> INSERT INTO Subject (SubjectID, SubjectName) VALUES
    -> (101, 'Math'),
    -> (102, 'Science'),
    -> (103, 'English');
 INSERT INTO Student_Subject (RollNo, SubjectID) VALUES
    -> (1, 101),
    -> (1, 103),
    -> (2, 102),
    -> (2, 103),
    -> (3, 101);
 SELECT
    ->   s.RollNo,
    ->   s.Name,
    ->   sub.SubjectName
    -> FROM
    ->   Student s
    ->   INNER JOIN Student_Subject ss ON s.RollNo = ss.RollNo
    ->   INNER JOIN Subject sub ON ss.SubjectID = sub.SubjectID
    -> ORDER BY s.RollNo;
+--------+--------------+-------------+
| RollNo | Name         | SubjectName |
+--------+--------------+-------------+
|      1 | Riya Sharma  | Math        |
|      1 | Riya Sharma  | English     |
|      2 | Aman Verma   | Science     |
|      2 | Aman Verma   | English     |
|      3 | Sanya Kapoor | Math        |
+--------+--------------+-------------+
5 rows in set (0.00 sec)

mysql> SELECT
    ->   s.RollNo,
    ->   s.Name,
    ->   ss.SubjectID,
    ->   sub.SubjectName
    -> FROM
    ->   Student s
    ->   INNER JOIN Student_Subject ss ON s.RollNo = ss.RollNo
    ->   INNER JOIN Subject sub ON ss.SubjectID = sub.SubjectID
    -> ORDER BY s.RollNo;
+--------+--------------+-----------+-------------+
| RollNo | Name         | SubjectID | SubjectName |
+--------+--------------+-----------+-------------+
|      1 | Riya Sharma  |       101 | Math        |
|      1 | Riya Sharma  |       103 | English     |
|      2 | Aman Verma   |       102 | Science     |
|      2 | Aman Verma   |       103 | English     |
|      3 | Sanya Kapoor |       101 | Math        |
+--------+--------------+-----------+-------------+

Alias	Refers to		Example usage
s	Student table		s.RollNo, s.Name
ss	Student_Subject table	ss.RollNo, ss.SubjectID
sub	Subject table		sub.SubjectName

INNER JOIN Student_Subject ss ON s.RollNo = ss.RollNo
â†’ Connect each student with their corresponding entries in the junction table.

INNER JOIN Subject sub ON ss.SubjectID = sub.SubjectID
â†’ Then connect that subject ID to get the actual subject name.
or Match each student (s.RollNo) with rows in Student_Subject having the same roll number.
Then, for those rows, match ss.SubjectID to Subject.SubjectID to find the subject name.

Mainpoints:-
Step	Action	Result
1	Start from Student		List of students
2	Join with Student_Subject	Find which subjects each student has
3	Join with Subject		Get actual subject names
4	Order by RollNo		Sort final output neatly

Third Normal Form (3NF):- A relation (table) is in Third Normal Form (3NF) when:

It is already in Second Normal Form (2NF), and
Every nonâ€“primary key attribute is not transitively dependent on the primary key.

In short:
There should be no transitive dependency.

ğŸ§© What is Transitive Dependency?

A transitive dependency means that a non-key attribute depends on the primary key through another non-key attribute.

ğŸ§  Example:

RollNo â†’ Semester  
Semester â†’ Hostel  
Therefore, RollNo â†’ Hostel (transitively)


This means that Hostel does not depend directly on RollNo,
but indirectly through Semester â€” this is a transitive dependency.

ğŸ“Š Example Table (Before 3NF)

Table: Student

RollNo	Name	Semester	Hostel
1	Lalit	1		H1
2	Gaurav	2		H2
3	Vishal	1		H1
4	Neha	4		H4
5	John	3		H3

Primary Key: RollNo

Dependencies:

RollNo â†’ Name

RollNo â†’ Semester

Semester â†’ Hostel âŒ (transitive dependency)

âš ï¸ Problems (Anomalies) in 2NF Table

ğŸ”¸ 1. Deletion Anomaly:
If we delete â€œGauravâ€ (RollNo 2, Hostel H2),
the information about Hostel H2 is also lost,
because no other student is in that hostel.

ğŸ”¸ 2. Insertion Anomaly:
If we want to add a new hostel â€œH8â€ that currently has no students,
we cannot insert it since thereâ€™s no RollNo.

3. Update Anomaly:
If the hostel for Semester 1 changes,
we need to update every student in Semester 1 manually.
If even one row is missed, the data becomes inconsistent.

Solution (Convert to 3NF)

To remove the transitive dependency (Semester â†’ Hostel),
we split the table into two smaller tables:

1. Student Table

RollNo	Name	Semester
1	Lalit	1
2	Gaurav	2
3	Vishal	1
4	Neha	4
5	John	3

Dependency: RollNo â†’ Name, Semester

2. Semester Table

Semester	Hostel
1	        H1
2	        H2
3	        H3
4	        H4

Dependency: Semester â†’ Hostel
Now the Database is in 3NF!
All non-key attributes depend only on the primary key.Transitive dependency is removed.
No Insertion, Deletion, or Update anomalies exist.

4.) Boyce Codd Normal Form (BCNF)
A table is in BCNF (Boyceâ€“Codd Normal Form) if:

For every functional dependency (X â†’ Y),
X must be a super key.

ğŸ”¹ In simple words:

BCNF = Stronger version of 3NF

It fixes cases where 3NF allows dependency between candidate keys.

ğŸ§¾ Step 3: Example (3NF but not BCNF)
StudentID	Course		Instructor
1		DBMS		Dr. Verma
2		DBMS		Dr. Verma
3		OS		Dr. Sharma
âš™ï¸ Functional Dependencies:

(StudentID, Course) â†’ Instructor âœ…

Instructor â†’ Course âŒ (Problem)

ğŸ” Why itâ€™s a problem:

Primary key = (StudentID, Course)

But â€œInstructorâ€ also determines â€œCourseâ€.

Instructor is not a super key, but still determines another attribute.
âŒ So this table violates BCNF (but itâ€™s okay in 3NF).

âœ… Step 4: Convert to BCNF

We decompose the table into two:

Table 1: InstructorCourse
Instructor	Course
Dr. Verma	DBMS
Dr. Sharma	OS
Table 2: StudentInstructor
StudentID	Instructor
1		Dr. Verma
2		Dr. Verma
3		Dr. Sharma

Now: In both tables, left side of every dependency is a super key. Table is now in BCNF.

4). What is 4NF?

A table is in 4NF if it is in BCNF,and it has no multi-valued dependencies (MVDs).

ğŸ”¹ What is a multi-valued dependency?

It happens when:One key attribute determines two or more independent sets of values.

In other words:

A single entity has multiple independent multi-valued facts stored in the same table.
Step 3: Example (violates 4NF)
Student	Hobby	Language
Riya	Painting	English
Riya	Painting	Hindi
Riya	Singing	English
Riya	Singing	Hindi
Explanation:

A student can have multiple hobbies
A student can know multiple languages
But hobby and language are independent of each other

Functional dependencies:

Student â†’â†’ Hobby

Student â†’â†’ Language

 Here â†’â†’ means multi-valued dependency (MVD)

So there are two independent MVDs on the same key (Student).

This table is in BCNF, but not in 4NF, because one key (Student) determines multiple independent sets of values (Hobby, Language).

Step 4: Fix (Decomposition for 4NF)

We split it into two tables ğŸ‘‡

Table 1: Student_Hobby

Student	Hobby
Riya	Painting
Riya	Singing

Table 2: Student_Language

Student	Language
Riya	English
Riya	Hindi

Now both tables are in 4NF,
because each table represents one independent multi-valued fact about the student.
in short:- If one entity (like a student) has multiple independent sets of values (hobbies, languages),
split them into separate tables â€” each for one independent relationship.

5). 5NF:-
A table is in Fifth Normal Form (5NF) if it is already in 4NF,
and cannot be decomposed further into smaller tables without losing data or creating redundancy.

A relation is in 5NF if every join dependency in it is implied by the candidate keys.

Step 3: Intuitive Meaning

ğŸ‘‰ 4NF removes multi-valued dependencies
ğŸ‘‰ 5NF removes join dependencies

Join Dependency = When information can be reconstructed by joining multiple smaller tables,
but we still store it together unnecessarily.

Basically:

5NF ensures there is no redundant data that can be reconstructed by joining smaller relations.

Step 4: Example (violates 5NF)
Table: Supplier_Product_Project
Supplier	Product	Project
S1	P1	J1
S1	P1	J2
S1	P2	J1
Meaning:

Supplier S1 supplies P1 and P2.

Supplier S1 supplies to projects J1 and J2.

So we get all possible combinations like:

(S1, P1, J1)

(S1, P1, J2)

(S1, P2, J1)

Problem:

There is redundancy here.
The relationships between Supplierâ€“Product, Supplierâ€“Project, and Productâ€“Project are independent,
but we are storing their combinations repeatedly.

This means the table can be decomposed further â€” hence, not in 5NF.

Step 5: Convert to 5NF

We break it into three smaller tables:

Supplier_Product

Supplier	Product
S1	P1
S1	P2

Supplier_Project

Supplier	Project
S1	J1
S1	J2

Product_Project

Product	Project
P1	J1
P1	J2
P2	J1

Now, when you join these three tables,
you can reconstruct the original table without redundancy.
Hence, this structure is in 5NF.
